/*
	key:F11
    1. 选择整个宏,     显示、添加宏说明
    2. 选择部分关键词,    显示、添加词说明; 
	3. 可选择多行
		LCD_NV3029G_SANLONG_CPT2	= TRUE
		LCD_GC9306_YIHUA_HSD      = TRUE
		LCD_GC9305_SANLONG_HSD2 = TRUE
	提示:
		NV3029G	三龙+CPT
		GC9306	亿华
		GC9305	三龙+HSD
	按确认，复制以上内容到剪切板，再粘贴到软件说明书中。
	
	4*. 未选择，复制文件名

Fun list:
	macro _TempHeadF11(hbuf){}
Note()
	LongNote(hbuf, key)
	ShortNote(hbuf, key)
	
	GetLongNote(key)
	GetMediumNote(key)
	GetShortNote(key)
NoteHander()

OpenF11Test(hbuf, v)



*/

macro Note()
{
	//_TempHeadF11(hbuf)
    hwnd = GetCurrentWnd()
    hbuf = GetCurrentBuf()
	if (hwnd == 0)
	{
    	hbuf = OpenDefaultSR(hbuf)
    	stop
	}
	
	sel = MGetWndSel(hbuf)
	if (IsSingleSelect(sel))
	{
		cur_line = GetBufLine(hbuf, sel.lnFirst )
		if(strlen(cur_line) < sel.ichLim)
			sel.ichLim = sel.ichLim - 1
		if(sel.ichFirst == sel.ichLim || 4095 == sel.ichLim)
			stop
			
		cur_sel = strmid(cur_line, sel.ichFirst, sel.ichLim)
		if(cur_sel == GetWholeMacro(cur_line, sel))
		{
			LongNote(hbuf, cur_sel)
		}
		else
		{
			ShortNote(hbuf, cur_sel)
		}
	}
	else if(IsMoreSelect(sel))
	{
		nTxt = ""
		i = sel.lnFirst
		while (i <= sel.lnLast)
		{
			line = GetBufLine(hbuf, i)
			iMacro = GetLineMacro(line)
			iNote = GetMediumNote(iMacro)
			
			if(iNote != "")
			{
				nTxt = nTxt # iNote # CharFromKey(13)
			}
			i = i + 1
		}
		if(nTxt != "")
		{
			msg("@nTxt@")
			SetClipString(nTxt)
		}
	}
	else
	{
		hprj = GetCurrentProj ()
		path = GetProjDir (hprj)
		bft = getBaseFileType(path, 3)
		if(bft == "")
			stop
		mFile = getNodePath(0) # "\\Macro_Note_@bft@.h"
	
		if(IsFileName(hbuf, "Macro_Note_"))
		{
			hwnd = GetCurrentWnd()
			lnTop = GetWndVertScroll(hwnd);
			SaveMode(getWndVertRow(0), "@lnTop@")
			close
		}
		else
		{
			lnTop = ReadMode(getWndVertRow(0))
			OpenExistFileRow(mFile, lnTop)
		}
	}
}

macro LongNote(hbuf, key)
{
	//_TempHeadF11(hbuf)
	nTxt = GetLongNote(key)
	if(nTxt == "")
	{
		nTxt = GetMediumNote(key)
	}
	if(nTxt != "")
	{
		ntStr = "@key@:" # CharFromKey(13)
		ntStr = ntStr # nTxt # CharFromKey(13)
		msg("@ntStr@")
		SetClipString(nTxt)
	}
	else //add noto
	{
		grMsg = "Add Long Note, Macro: @key@" # CharFromKey(13)
		ntStr = Ask("@grMsg@")
		
		ntRule = OpenCache(getNodePath(0) # "\\Macro_Note_Long.h")
		ntStr = "key:@key@,@ntStr@"
		AppendBufLine(ntRule, "@ntStr@")
		SaveBuf(ntRule)
		CloseBuf(ntRule)
	}
}

macro GetLongNote(key)
{
	//_TempHeadF11(hbuf)
	mFile = getNodePath(0) # "\\Macro_Note_Long.h"
	mBuf = OpenCache(mFile)
	mKey = "key:" # key # ","
	mSel = SearchInBuf(mBuf, mKey, 0, 0, FALSE, FALSE, FALSE)
	nTxt = ""

	while (mSel != "")
	{
		line = GetBufLine(mBuf, mSel.lnFirst )
		ilen = strlen(line)
		
		ich = SplitMacro(line, ",", 0, ilen)		
		nTxt   = strmid(line, ich + 1, ilen) # CharFromKey(13)
		
		mSel = SearchInBuf(mBuf, mKey, mSel.lnLast+1, 0, 0, 0, 0)
	}
	CloseBuf(mBuf)
	return nTxt
}

macro GetMediumNote(key)
{
	//_TempHeadF11(hbuf)
	mFile = getNodePath(0) # "\\Macro_Note_Short.h"
	mBuf = OpenCache(mFile)
	nTxt = ""
	
	klen = strlen(key)
	iStart = 0
	ichKey = SplitMacro(key, "_", iStart, klen)
	while (1)
	{
		if(ichKey >= 0)
		{
			ikey = strmid(key, iStart, ichKey)
		}
		else
		{
			ikey = strmid(key, iStart, klen)
		}
		iStart = ichKey + 1
		
		mKey = "key:" # ikey # ","
		mSel = SearchInBuf(mBuf, mKey, 0, 0, FALSE, FALSE, FALSE)
		if (mSel != "")
		{
			line = GetBufLine(mBuf, mSel.lnFirst )
			ilen = strlen(line)
			
			ich = SplitMacro(line, ",", 0, ilen)
			if (ich > 0)
			{
				nTxt = nTxt # strmid(line, ich + 1, ilen)
			}
		}
		if(ichKey < 0)
		{
			break
		}
		ichKey = SplitMacro(key, "_", iStart, klen)
	}
	CloseBuf(mBuf)
	return nTxt
}

macro ShortNote(hbuf, key)
{
	//_TempHeadF11(hbuf)
	nTxt = GetShortNote(key)
	if(nTxt != "")
	{
		ntStr = "@key@:" # CharFromKey(13)
		ntStr = ntStr # nTxt # CharFromKey(13)
		msg("@ntStr@")
		SetClipString(nTxt)
	}
	else //add noto
	{
		grMsg = "Add Short Note, Macro: @key@" # CharFromKey(13)
		ntStr = Ask("@grMsg@")
		tabStr = CharFromKey(9)
		
		ntRule = OpenCache(getNodePath(0) # "\\Macro_Note_Short.h")
		ntStr = "key:@key@,@tabStr@@ntStr@"
		AppendBufLine(ntRule, "@ntStr@")
		SaveBuf(ntRule)
		CloseBuf(ntRule)
	}
}

macro GetShortNote(key)
{
	//_TempHeadF11(hbuf)
	mFile = getNodePath(0) # "\\Macro_Note_Short.h"
	mBuf = OpenCache(mFile)
	mKey = "key:" # key # ","
	mSel = SearchInBuf(mBuf, key, 0, 0, FALSE, FALSE, FALSE)
	nTxt = ""

	if (mSel != "")
	{
		line = GetBufLine(mBuf, mSel.lnFirst )
		ilen = strlen(line)
		
		ich = SplitMacro(line, ",", 0, ilen)
		if (ich > 0)
		{
			nTxt   = strmid(line, ich + 1, ilen)
		}
	}
	CloseBuf(mBuf)
	return nTxt
}

//Note press F5,F6
macro NoteHander(hbuf, cNum)
{
	var noteCmd
	var noteWord
	
	sel = MGetWndSel(hbuf)
	cur_line = GetBufLine(hbuf, sel.lnFirst )
	cur_row = sel.ichFirst

	start = StartWS(cur_line, 0 )
	if (start == "X")
	{
		stop
	}
	else if (start > 0)
	{
		//delete left
		cur_line = strmid(cur_line, start, strlen(cur_line))
	}
	len = strlen(cur_line)
	
	//用第1个词作为命令区分;以":"、" "分开
	//{0,index} 为命令
	indexa = FindString(cur_line, ":")
	indexb = FindString(cur_line, " ")	
	if (indexa == "X" && indexb == "X")
	{
		index = len
	}
	else if (indexa == "X")
	{
		index = indexb
	}
	else if (indexb == "X")
	{
		index = indexa
	}
	else if (indexa>indexb)
	{
		index = indexb
	}
	else
	{
		index = indexa
	}
	
	//msg(start # ";" # index)
	noteCmd = strmid(cur_line, 0, index)
	
	//msg(noteCmd # ";")
	if(noteCmd == "replace")
	{
		//跳转到复制对应的语言/宏
		cur_line = GetClipString(hbuf)
	}
	else if(noteCmd == "open")
	{
		//open tools or file; {save} as path
		//下一个非空
		start = StartWS(cur_line, index + 1)
		if (start == "X")
		{
			stop
		}
		//下一个空格
		next = NextWS(cur_line, start)
		if (next == "X")
		{
			next = len
		}
		vcPath = strmid(cur_line, start, next)
		pi = FindString(vcPath, "{save}")
		if(pi != "X")
		{
			vcPath = getSavePath(0) # strmid(vcPath, pi + strlen("{save}"), strlen(vcPath))
		}
		else
		{
			pi = FindString(vcPath, ":")
			if(pi == "X")
			{
				vcPath = getBasePath(hbuf) # "\\" # vcPath
			}
		}
		lastStr = strmid(cur_line, next, len)
		
		//exe file
		if(IsExeFile(vcPath))
		{
			ShellExecute("open", vcPath, "", "", 1)
		}
		else
		{
			vcbuf = OpenExistFile(vcPath)
				
			if (vcbuf != hNil){
				if (lastStr != "")
				{
					mSel = SearchInBuf(vcbuf, "@lastStr@", 0, 0, 0, 0, 0)
					if (mSel != "")
					{
						ScrollCursor(mSel)
					}
				}
			}
		}
	}
	else if(noteCmd == "cmd")
	{
		//仅仅打开cmd后面不需要接路径
		ShellExecute("open", getBasePath(hbuf) # "\\cmd", "", "", 1)
	}
	else if(noteCmd == "make")
	{
		//仅仅打开cmd后面不接路径
		lastCmd = strmid(cur_line, start, len)
		hbufClip = GetBufHandle("Clipboard")
		if (hbufClip != hNil)
		{
			EmptyBuf(hbufClip)
			AppendBufLine(hbufClip, "@lastCmd@")
			CloseBuf(hbufClip)
		}
		ShellExecute("open", getBasePath(hbuf) # "\\cmd", "", "", 1)
	}
	else if(noteCmd == "ctmake" || noteCmd == "xmake")
	{
		//仅仅打开cmd后面不接路径
		lastCmd = strmid(cur_line, start, len)
		hbufClip = GetBufHandle("Clipboard")
		if (hbufClip != hNil)
		{
			EmptyBuf(hbufClip)
			AppendBufLine(hbufClip, "@lastCmd@")
			CloseBuf(hbufClip)
		}
		//Cygwin...
	}
	else if(noteCmd == "vc")
	{
		vcPath = getVCPath(0)
		lastCmd = strmid(cur_line, index + 1, len)
		ShellExecute("open", vcPath, getBasePath(hbuf) # "\\" # lastCmd, "", 1)
	}
	else if(noteCmd == "vs08")
	{
		vcPath = getVS08Path(0)
		lastCmd = strmid(cur_line, index + 1, len)
		ShellExecute("open", vcPath, getBasePath(hbuf) # "\\" # lastCmd, "", 1)
	}
	else if(noteCmd == "call")
	{
		lastCmd = strmid(cur_line, index, len)
		hbufClip = GetBufHandle("Clipboard")
		if (hbufClip != hNil)
		{
			EmptyBuf(hbufClip)
			AppendBufLine(hbufClip, "@lastCmd@")
			CloseBuf(hbufClip)
		}
	}
	else if(noteCmd == "set")
	{
		//lastCmd:除set以外的str
		lastCmd = strmid(cur_line, index+1, len)
		//旧列表替换为新列表,空格分开 
		SetNoteHander(hbuf, lastCmd, cur_row)
		
	}
	else if(noteCmd == "setPath")
	{
		//lastCmd:除setPath以外的str
		lastCmd = strmid(cur_line, index+1, len)
		//开始路径列表替换
		SetPathNoteHander(hbuf, lastCmd)
	}
	else if(noteCmd == "setProPath")
	{
		msg("setPath的替换列表, 暂时不单独替换")
	}
	else if(strlen(noteCmd)>0)
	{
		curPath = noteCmd

		/*
		//项目文件可能在不同目录, 加{P}获取具体路径
		pi = FindString(curPath, "{P}")
		if(pi != "X")
		{
			curPath = strmid(curPath, pi + strlen("{P}"), index)
			//当前项目是否特定项目路径
			proMode = getMacroValue(hbuf, "proPathMode", 1)
			//F5进行路径转换; F6不转换
			if(proMode == "proPathT" && cNum == 5)
			{
				//路径转换
				//文件名转换
				filename = GetFileName(curPath)
				fileConv = getMacroValue(hbuf, filename, 1)
				if(fileConv != "")
				{
					filename = fileConv
				}
				CurPath = getMacroValue(hbuf, "CurProPath", 1) # "\\" # filename
			}
		}
		*/
		
		//default open file + gote word
		if(strmid(curPath,0,1)!="\\" && strmid(curPath,0,1)!="/")
			curPath = "\\" # curPath
		//msg(CurPath)
		hbuf = OpenExistFile(getBasePath(hbuf) # curPath)
			
		if (hbuf != hNil){
			if (indexb == "X" || indexb == len)
			{
				stop
			}
			//下一个非空
			start2 = StartWS(cur_line, indexb)
			if (start2 == "X")
			{
				stop
			}
			//下一个空格
			next = NextWS(cur_line, start2)
			if (next == "X")
			{
				next = len
			}
			
			{
				//保存value到剪切板
				otherWord = strmid(cur_line, indexb+1, len)
				lnVar = GetLineValue(otherWord)
				if(lnVar != "")
				{
					SetClipString(lnVar)
				}
			}

			//goto word and selete
			noteWord = strmid(cur_line, indexb+1, next)
			//use "^" as space
			noteWord = ReplaceWord(noteWord, "^", " ")

			//优先搜索行首
			mSel = SearchInBuf(hbuf, "^" # "@noteWord@", 0, 0, 0, 1, 0)
			if (mSel == "")
			{
				mSel = SearchInBuf(hbuf, "@noteWord@", 0, 0, 0, 0, 0)
			}
			if (mSel != "")
			{
				ScrollCursor(mSel)
			}
		}
	}

}

//旧列表替换为新列表,空格分开
macro SetNoteHander(hbuf, lastCmd, cur_row)
{
	//msg("-" # lastCmd # "-")
	lastBaseCmd = ReadMode(getNoteHanderSet(0))
	if(lastBaseCmd == lastCmd)
		stop
	SaveMode(getNoteHanderSet(0), "@lastCmd@")
	
	{
		//结束标志
		noteWord = "setEnd:"
		mSel = SearchInBuf(hbuf, "@noteWord@", 0, 0, 0, 0, 0)
		if (mSel != "")
		{
			cur_row = mSel.lnFirst
		}
		else
		{
			cur_row = cur_row + 8
		}
	}
	
	len = strlen(lastCmd)
	lenB = strlen(lastBaseCmd)
	if (0 == len || 0 == lenB)
		stop
	i = 0
	iB = 0
	while (1)
	{
		//查新旧列表的替换字符
		next = NextWS(lastCmd, i)
		nextB = NextWS(lastBaseCmd, iB)
		//msg("-" # lastBaseCmd # "-" # next # "-" # nextB # "-")
		if (next == "X" || nextB == "X")
		{
			//最后一次替换
			next = len
			nextB = lenB
			noteWord = strmid(lastCmd, i, next)
			noteWordB = strmid(lastBaseCmd, iB, nextB)
			DoReplaceRow(hbuf, noteWordB, noteWord, cur_row + 1, FALSE)
			SaveBuf(hbuf) //需求多次保存, 否则会有问题
			break
		}
		else
		{
			noteWord = strmid(lastCmd, i, next)
			noteWordB = strmid(lastBaseCmd, iB, nextB)
			DoReplaceRow(hbuf, noteWordB, noteWord, cur_row + 1, FALSE)
			SaveBuf(hbuf) //需求多次保存, 否则会有问题
		}
		start = StartWS( lastCmd, next )
		startB = StartWS( lastBaseCmd, nextB )
		i = start
		iB = startB
	}
}

//旧列表替换为新列表,空格分开
macro SetPathNoteHander(hbuf, lastCmd)
{
	var setItem
	//下一个空格
	next = NextWS(lastCmd, 0)
	if (next == 0)
	{
		//下一个非空
		start = StartWS(lastCmd, 0)
		if (start == "X")
		{
			stop
		}
		lastCmd = strmid(lastCmd, start, strlen(lastCmd))
		//下一个空格
		next = NextWS(lastCmd, 0)
	}
	
	if (next != "X")
	{
		lastCmd = strmid(lastCmd, 0, next)
	}
	
	{
		//结束标志
		mKey = "setEnd:"
		mSel = SearchInBuf(hbuf, "@mKey@", 0, 0, 0, 0, 0)
		if (mSel != "")
		{
			cur_row = mSel.lnFirst
		}
		else
		{
			cur_row = cur_row + 8
		}
	}
	{
		//项目路径 (合并到以下替换内容)
		mKey = "CurProPath"
		curProPath = getMacroValue(hbuf, mKey, 1)
	}

	

	//搜索替换列表, 单项可以注释掉
	mKey = "^" # "setProPath"
	lenKey = strlen("setProPath")
	mSel = SearchInBuf(hbuf, mKey, 0, 0, FALSE, TRUE, FALSE)
	nTxt = ""

	setItem = ""
	while (mSel != "")
	{
		line = GetBufLine(hbuf, mSel.lnFirst )
		ilen = strlen(line)

		//下一个非空
		start = StartWS(line, lenKey)
		if (start != "X")
		{
			setItem = strmid(line, start, strlen(line))
			lnMar = GetLineMacro(setItem)
			lnVar = curProPath # "\\\\" # GetLineValue(setItem)
			
			if (lastCmd == "new")
			{
			 	//路径包括正反斜杠
				lnMar = "^" # ReplaceWord(lnMar, "\\\\", "[\\\\/]")
				
			 	//替换内容去掉一个反斜杠
				lnVar = ReplaceWord(lnVar, "\\\\", "\\")
				
				//msg("[" # lnMar # "]" # CharFromKey(13) # "[" # lnVar # "]")
				
			 	//isRule = TRUE: 设置参数列表从行首替换;否则会替换掉设置列表
				DoReplaceRow(hbuf, lnMar, lnVar, cur_row + 1, TRUE)
				//需求多次保存, 否则会有问题
				SaveBuf(hbuf)
			}
			else if (lastCmd == "old")
			{
			 	//路径包括正反斜杠
				lnVar = "^" # ReplaceWord(lnVar, "\\\\", "[\\\\/]")
				
			 	//替换内容去掉一个反斜杠
				lnMar = ReplaceWord(lnMar, "\\\\", "\\")
				
				//msg("[" # lnVar # "]" # CharFromKey(13) # "[" # lnMar # "]")
				
			 	//isRule = TRUE: 设置参数列表从行首替换;否则会替换掉设置列表
				DoReplaceRow(hbuf, lnVar, lnMar, cur_row + 1, TRUE)
				//需求多次保存, 否则会有问题
				SaveBuf(hbuf)
			}
		}
		
		mSel = SearchInBuf(hbuf, mKey, mSel.lnLast+1, 0, FALSE, TRUE, FALSE)
	}

}

macro OpenF11Test(hbuf, v)
{
}

